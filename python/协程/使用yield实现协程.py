"""
Python多线程是假的多线程,由于GIL(全局锁)存在,同时只有一个线程运行,只不过是不断切换A线程B线程而已.一会干A线程,一会干B线程.
使用协程来解决python多线程不行的问题.进程-线程-协程.在python中协程通过yield来调用其它协程.通过yield方式转义线程的执行权
gevent内部是封装的libev异步事件循环。所以，要理解gevent，首先需要对linux的异步I/O有个概念。
举例:打开一个网页，需要cpu向网卡发送指令，如果是阻塞情况，cpu会一直等待直到网卡通过网络获取到了网页内容，才会继续工作，
这样整个工作都是序列化的，并且等待的时间啥都做不了，很显然浪费了cpu。异步的情况则是cpu把指令成功发送给网卡并注册了回调函数以后，
就直接返回做其他事情.
cpu向网卡提交了一个网页链接访问请求以后，不等待网卡就继续向网卡提交下一个网页请求(网卡本身也是有控制器的，
可以很好的并发处理多个网页请求)。在网卡获取到网页内容以后，通过中断机制告诉cpu，网页获取成功了。cpu接收到通知以后，可以中断当前
的执行流程去执行之前注册的回调函数(由于网卡是并发访问网页的，每个网页返回的时间不同导致了回调函数的顺序发生变化)。
Gevent让程序员不用注册Callback直接用同步的方式写代码
"""
import time


def a():
    while True:
        print('----a----')
        yield
        time.sleep(2)


def b(parm):
    while True:
        print('----b----')
        parm.__next__()
        time.sleep(2)


if __name__ == '__main__':
    foo =a()  # foo现在变成生成器了
    b(foo) # 这段代码展示的是两个函数互相切换主线程执行权

